<div class="html-des collapse" id="html-router">
        <p>
            <span class="subject">1. HTML 구조</span>
            <br> 1.1. html 파일은 index.html > template > view 의 부모관계를 가진다.
            <br> 1-2. index.html에서 ui-router로 각 template를 불러오고 template에서 ng-include를 통해 view를 불러오는 방식을 이용
            <br> 1.3. /assets/js/angular-app.js 에서 ui-router를 관리한다.
            <br>
        </p>
        <p>
            <span class="subject">2. *ui-router</span>
            <button type="button" class="btn btn-secondary" data-toggle="popover" data-content='<img src="images/routing-code.jpg">'>
                소스코드 보기
            </button>
            <br> 2-1. ui-router에서는 index.html의
            <code>&lt;div ng-view&gt;</code> 를 기준으로 화면을 전환하는 라우팅서비스를 제공한다.
            <br> 2-2. 모든 routing template의 url은 ''로 공백이며 data로 pageTitle 값을 보낸다. pageTitle은 web title을 바꾸는데 이용
            <br> 2-3. template / templateUrl 을 이용해서 템플릿값을 설정한다.
            <br> 2-4. ui-router에 app.analysis, app.map, app.elog, app.data, app.mrv 와 같이
            <br> template에 <code> &lt;div ng-view&gt;&lt;/div&gt; </code>이 선언되어 있는데 이는 다중 라우터를 이용하기 위한 구문으로 보인다.
            <span class="guess"></span>
            <span class="question"></span>
            <br> 2-5. state값을 이용하여 라우팅페이지를 구분한다. 이 값은 controller에서 $state 모듈를 로드하여 사용가능하다.
        </p>
        <p>
            <span class="subject">3. *다중 라우팅</span>
            <span class="guess"></span>
            <br> 3-1. (2-4) 에 언급된 다중 라우팅에 관한 설명이다.
            <br> 3-2. ParentState.ChildState.GrandChildState 와 같은 형태로 다중 라우팅 구성이 가능하다.
            <br> 3-3. template에 &lt;div ng-view&gt;&lt;/div&gt;가 선언된 이유가 다중 라우팅을 구성하기 위한 기반으로 보인다.
            <br> 3-4. 
        </p>
        <p>
            <span class="subject">4. *resolve (ui-router의 기능)</span>
            <br> 4-1. resolve는 ui-router를 통해 불러오는 라우팅 템플릿에 넘겨줄 데이터를 로드하는 기능이다.
            <br> 4-2. resolve를 통해서 해당 template에 해당하는 controller.js 와 assets/plugins 의 필요한 기능을 로드한다.
            <br>
        </p>
        <p>
            <span class="subject">5. *ocLazyLoad (ui-router library)</span>
            <br> 5-1. ocLazyLoad는 영역간의 물리적인 번들을 구분할 수 있도록 해준다.
            <br> 5-2. 이를 통해서 라우팅 될때마다 모든 모듈을 불러오는 것을 막을 수 있고 라우팅 로드 속도를 향상시킬 수 있다.
            <br> 5-3. 하지만 각각 별도의 번들에 접근 권한을 인증받지 않기 때문에 보안 이슈가 존재한다.
        </p>
        <p>
            <span class="subject">*ocLazyLoad parameters { name - type(defaultValue) }</span>
            <br> 1. cache - boolean(true) : 'cache: false'는 모든 기본 로더에서 작동하며
            <br> 이것을 사용하면 로더는 브라우저 캐시를 우회하기 위해 URL에 타임 스탬프를 추가한다.
            <br> 2. reconfig - boolean(false) : 모듈을 다시 로드하면 기본적으로 예기치 않은 결과가 발생할 수 있으므로
            <br>config 블록이 다시 호출되지 않습니다. 이때 config 함수 호출이 반드시 필요하면 'reconfig: true' 속성값을 주면 된다.
            <br> 3. rerun - boolean(false) : reconfig와 같이 run을 반드시 다시 실행해야할때 'rerun: true'값을 주면 된다.
            <br> 4. serie(serial) - boolean(false) : 기본적으로 로더는 파일을 병렬로 로드한다.
            <br> 파일을 직렬로 로드해야하는 경우 'serie : true'를 사용할 수 있습니다.
            <br> 5. insertBefore - boolean(undifined) : 기본적으로 file은 head 요소의 마지막 요소 앞에 삽입된다.
            <br> 하지만 'insertBefore: cssSelector'를 사용하여 이를 재정의 할 수 있습니다.
        </p>
        <p>
            <span class="subject">6. $state</span>
            <br> 6-1. SPMS 페이지는 ui.router 모듈의 state 속성값으로 route를 수행한다.
            <br> 6-2. state 값은 controller에서 $state 파라미터로 받아올 수 있다. <code>($state.$current.name) </code>
            <br> 6-3. angular-controler.js 에서 페이지 변경시 마다 switch문을 통해서 animation과 $rootScope.setting.layout 값 등을 변경한다.
            <br> 6-4. DOM이 새롭게 로딩될 때마다 documentReady() 메소드를 실행한다.
            <br> 6-5. documentReady()은 상단 nav bar의 데이터를 관리한다. (update log modal, , now selected ship's departure, arrival
            point)
        </p>

    </div>